# Problem 1015 土地划分

### Accept: 881    Submit: 2106 Time Limit: 1000 mSec    Memory Limit : 32768 KB

## ![img](http://acm.fzu.edu.cn/image/prodesc.gif) Problem Description

在Dukeswood这块土地上生活着一个富有的农庄主和他的几个孩子。在他临终时，他想把他的土地分给他的孩子。他有许多农场，每个农场都是一块矩形土地。他在农场地图上划上一些直线将矩形分成若干块。当他划直线时，他总是从矩形边界上的某一点划到另一个矩形边界上的点，这条线的结束点将成为下一条线的起始点。他划线时从不会让任三线共点。例如图1是某一种划分结果。



![img](http://acm.fzu.edu.cn/image/Problem/1015.bmp)

​                                                                                              图1

划分的起始点和结束点均以五角星标记。当他完成划分后，他想要数一下划出的土地的块数以确保每个孩子都有一块地。例如，图1中土地被划分成18块。然而这个庄主由于年迈常会数错，因而他寻求你的帮助。

请写一个程序，输入原来的土地尺寸及线段的位置，输出划分出的土地块数。

## ![img](http://acm.fzu.edu.cn/image/prodesc.gif) Input

输入文件有多组数据组成。每组数据格式如下：
第一行输入地图的宽度w (1<=w<=1000)和高度 h (1<=h<=1000)，均为整数。
第二行输入线段数L (1<=L<=50)。
以下L+1行每行一个整数坐标(Xi,Yi)，庄主划的线段为(Xi,Yi)-(Xi+1,Yi+1)，i=1,2,…,L。当然(Xi,Yi)必定在矩形的边界上。
最后一组数据w=h=0，标志文件结束，不需要处理。

## ![img](http://acm.fzu.edu.cn/image/prodesc.gif) Output

对于给定的输入，输出一行仅含一个数，即划分出的土地块数。

## ![img](http://acm.fzu.edu.cn/image/prodesc.gif) Sample Input

>18 12
>
>8
>
>2 0
>
>6 12
>
>10 0
>
>18 9
>
>15 12
>
>0 6
>
>14 0
>
>10 12
>
>0 9
>
>7 6
>
>6
>
>2 0
>
>5 6
>
>7 3
>
>0 3
>
>3 0
>
>3 6
>
>0 5
>
>0 0 

## ![img](http://acm.fzu.edu.cn/image/prodesc.gif) Sample Output

> 18
>
> 11

## 解决方案

结论：平面上*n*条直线最多可以将平面分成*f*(*n*)个区域，其中

*f*(*n*)=（n<sup>2</sup>+n+2）/2

设*f*(*n*)为前*n*条输入的线段将矩形分成的区域个数，1≤ *n* ≤ *L*，*L*为线段总数。

**边界**:  f(1) = 2，即一条线段将矩形分成2个区域，如下图 (a)所示。

**递推**：假设现在已经处理了*n*-1条线段，新线段为*l*，它和已有的*n*-1条线段交于*t*(*n*)个交点。注意其中有些交点在矩形边界上，这些交点也是线段的端点，必须将其排除，于是剩下*t*(*n*)个交点。如下图 (b)所示。由于题目中限定“任三线不共点”，因此这些交点将l分成t(n)+1条线段。这t(n)+1条线段将所在区域一分为二，这样就增加了t(n)+1个区域。

![1015_1](F:\作业\FZOJ200笔记\1015_1.png)

![1015_2](F:\作业\FZOJ200笔记\1015_2.png)

u［1.. L］为线段序列，其中u[i]为第i条线段。计算过程如下

> T←0；｛交点数初始化｝
>
> for i←1 to L do｛统计*L*条线段之间的交点个数｝
>
> ​    for j←i+1 to L do 
>
> ​        if **u[i]**与**u[j]**相交then T←T+1；
>
> 输出T+L+1；

接下来是如何判断两线段是否相交，利用**跨立实验**

> **快速排斥试验**:
>
> 设以线段 P1P2 为对角线的矩形为R， 设以线段 Q1Q2 为对角线的矩形为T，如果R和T不相交，显然两线段不会相交。
>
> **跨立实验**:
>
> （PS：下面的公式中*代表点积，×代表叉积）
>
>
> 如果两线段相交，则两线段必然相互跨立对方。
>
> 若P1P2跨立Q1Q2 ，则矢量 ( P1 - Q1 ) 和( P2 - Q1 )位于矢量( Q2 - Q1 ) 的两侧，
>
> 即( P1 - Q1 ) × ( Q2 - Q1 ) * ( P2 - Q1 ) × ( Q2 - Q1 ) < 0。
>
> 上式可改写成( P1 - Q1 ) × ( Q2 - Q1 ) * ( Q2 - Q1 ) × ( P2 - Q1 ) > 0。
>
> 当 ( P1 - Q1 ) × ( Q2 - Q1 ) = 0 时，说明 ( P1 - Q1 ) 和 ( Q2 - Q1 )共线，但是因为已经通过快速排斥试验，所以 P1 一定在线段 Q1Q2上；
>
> 同理，( Q2 - Q1 ) ×(P2 - Q1 ) = 0 说明 P2 一定在线段 Q1Q2上。
>
> 所以判断P1P2跨立Q1Q2的依据是：( P1 - Q1 ) × ( Q2 - Q1 ) * ( Q2 - Q1 ) × ( P2 - Q1 ) >  0。
>
> 同理判断Q1Q2跨立P1P2的依据是：( Q1 - P1 ) × ( P2 - P1 ) * ( P2 - P1 ) × ( Q2 - P1 ) >  0。 
>
> 看懂这个公式需要掌握的数学知识：向量的叉积和向量的点积。
>
> 向量的点积：
>
>               给你两个向量A（ax,by）,B(bx,by).
>      
>               向量A和B的点积公式：A*B=ax*bx+ay*by.
>
> 向量的叉积：
>
>              给你两个向量A(ax,by) ，B(bx,by).
>      
>              向量的叉积公式：A×B=ax*by-ay*bx.
>
> 具体请看原文
>
> 作者：cfreezhan 
> 原文：https://blog.csdn.net/freezhanacmore/article/details/7894751 

```cpp
#include<stdio.h>
int main()
{
	int w, h, l;
	int x[55], y[55];
	int i;
	int ans;
	while (scanf("%d%d", &w, &h) != EOF && w != 0 && h != 0)
	{
		//开始若有两条线则必定把矩形分成3块，且中间没有交点
		ans = 3;
		scanf("%d\n", &l);
		for (i = 0; i <= l; i++)
			scanf("%d%d", &x[i], &y[i]);
		if (l < 3)//当矩形中的线段小于三条时，分得的面积，就是线段数加上1;
		{
			ans = l + 1;
			printf("%d\n", ans);
			continue;
		}
		else
		{
			//当矩形中的线段大于三条时，每多出一条线，就会多出一个面，
			//然后多出的这条线与前面所有的线像比，若多出一个交点则，多出一个面
			for (i = 3; i <= l; i++)
			{
				ans++;
				int k = i - 2;
				//跨立试验，利用叉积判断是否相交
				while (k > 0)
				{
					int s1 = (x[i - 1] - x[k - 1])*(y[k] - y[k - 1]) - (y[i - 1] - y[k - 1])*(x[k] - x[k - 1]);
					int s2 = (x[k] - x[k - 1])*(y[i] - y[k - 1]) - (y[k] - y[k - 1])*(x[i] - x[k - 1]);
					if (s1*s2 > 0)
						ans++;
					k--;
				}
			}
		}
		printf("%d\n", ans);
	}
	return 0;
}
```

